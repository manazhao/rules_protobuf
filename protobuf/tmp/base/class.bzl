load("//bzl:util.bzl", "get_offset_path")


def implement_compile_attributes(lang, self):
    """Add per-language attributes for the proto_compile rule"""

    attrs = self["attrs"]
    name = lang.name
    genlang = "gen_" + name

    # An attribute that enables/disables processing for this
    # language.
    attrs[genlang] = attr.bool(default = True)

    # Additional per-language options to the protobuf generator.  This
    # can either be implemented by the a plugin or protoc itself.
    attrs[genlang + "_protobuf_options"] = attr.string_list()

    # Allows the user to override the label that points to the plugin
    # binary, if configured on the language descriptor.
    if hasattr(lang, "protobuf") and hasattr(lang.protobuf, "executable"):
        attrs["gen_" + name + "_protobuf_plugin"] = attr.label(
            default = Label(lang.protobuf.executable),
            cfg = HOST_CFG,
            executable = True,
        )

    if hasattr(lang, "grpc"):
        # If this language supports gRPC, add this boolean flag in to
        # enable it.
        attrs[genlang + "_grpc"] = attr.bool()

        # If this language uses a separate plugin for the grpc part,
        # add an attribute that makes it configurable
        if hasattr(lang.grpc, "executable"):
            attrs[genlang + "_grpc_plugin"] = attr.label(
                default = Label(lang.grpc.executable),
                cfg = HOST_CFG,
                executable = True,
            )

        # Additional options to the grpc plugin.
        attrs[genlang + "_grpc_options"] = attr.string_list()


def implement_compile_outputs(lang, self):
    """
    Add customizable outputs for the proto_compile rule.  At this point
    only used by java.
    """
    if hasattr(lang, "protobuf") and hasattr(lang.protobuf, "outputs"):
        self["outputs"] += lang.protobuf.outputs
    if hasattr(lang, "grpc") and hasattr(lang.grpc, "outputs"):
        self["outputs"] += lang.grpc.outputs


def implement_compile_output_to_genfiles(lang, self):
    """
    Configures the genfiles output location.
    """
    self["output_to_genfiles"] = getattr(lang, "output_to_genfiles", self["output_to_genfiles"])


def build_generated_filename_extensions(lang, self):
    """
    Build a list of filename extensions that are generated by this language.
    """

    ctx = self["ctx"]
    exts = []

    if hasattr(lang, "protobuf"):
        exts += getattr(lang.protobuf, "file_extensions", [])

    if self["with_grpc"] or getattr(ctx.attr, "gen_" + lang.name + "_grpc", False):
        if hasattr(lang, "grpc"):
            exts += getattr(lang.grpc, "file_extensions", [])

    self["exts"] += exts


def build_generated_files(lang, self):
    """Build a list of files we expect to be generated."""

    # Does this language generate and files?  Most do.
    exts = self["exts"]

    if not exts:
        return
    ctx = self["ctx"]

    if ctx.attr.verbose > 2:
        print("generated_file extensions for language %s: %s" % (lang.name, exts))

    protos = self["protos"]
    if not protos:
        fail("Empty proto file input list.")

    for file in protos:
        base = file.basename[:-len(".proto")]
        for ext in exts:
            pbfile = ctx.new_file(base + ext)
            self["outputs"] += [pbfile]


def build_imports(lang, self):
    """Assemble the list of imports"""
    ctx = self["ctx"]

    # Start with root
    imports = [self["execdir"]]

    # Add any imports added in by language implementations.
    imports += self.get("imports", [])

    # Add user-specified ones (list of strings for this one)
    imports += ctx.attr.imports

    # Add in a workspace root for files specified in external
    # workspaces, taking into account the root offset.
    # for file in ctx.files.proto_paths:
    #     path = file.path.split("/")
    #     if path[0] == "external":
    #         imports += ["/".join(path[0:2])]

    # Save into shared state
    self["imports"] = imports

    # if we elect to support transitive imports, this would be the
    # place to do it.  Not sure if this will increase complexity for
    # the user and cause problems, so leaving it out for now.
    #
    #for dep in ctx.attr.proto_deps:
    #    ...



def build_package_prefix(lang, self):
    """The package prefix.  This is only used by go"""
    pass


def build_plugin_out(name, key, lang, self):
    """Build the --{lang}_out argument for a given plugin (protobuf,grpc)"""

    # Does the language descriptor contain a section for this plugin
    # type 'protobuf' or 'grpc'?
    if not hasattr(lang, key):
        return

    plugin = getattr(lang, key)
    ctx = self["ctx"]

    # The name of the attribute where the user can configure
    # additional options.
    plugin_options_key = "_".join(["gen", lang.name, key, "options"])

    # Compile a list of options, starting with defaults if they exist.
    opts = getattr(plugin, "default_options", [])

    # Add in any that were specified by the rule attributes
    opts += getattr(ctx.attr, plugin_options_key, [])

    # Add in any that were generated by the language implementation.
    opts += self.get(plugin_options_key, [])

    # Build the final list of plugin arguments.
    plugin_args = self["outdir"]

    if opts:
        plugin_args = ",".join(opts) + ":" + plugin_args
    self["args"] += ["--%s_out=%s" % (name, plugin_args)]


def build_protobuf_out(lang, self):
    """Build the --{lang}_out option"""
    build_plugin_out(lang.name, "protobuf", lang, self)


def build_grpc_out(lang, self):
    """Build the --grpc_out option if required"""
    build_plugin_out("grpc", "grpc", lang, self)


def build_plugin_invocation(key, lang, self):
    """Add a '--plugin=NAME=PATH' argument if the language descriptor
    requires one.  key can be 'protobuf' or 'grpc'
    """

    # Does the language class have a descriptor for this plugin? (a
    # struct; the two are 'protobuf' and 'grpc')
    if not hasattr(lang, key):
        return

    # If there is no property 'executable' on the struct, this
    # language does not use a plugin for the task (built-in to protoc
    # itself).  In this case we don't need a '--plugin' option.
    # Nothing more to do.
    plugin = getattr(lang, key)
    if not hasattr(plugin, "executable"):
        return

    ctx = self["ctx"]

    # The name of the attribute where the protoc plugin binary can be
    # configured on the rule, like "gen_go_protobuf_plugin".  This
    # will be store in the dict of executable tools for the rule.
    plugin_binary_key = "_".join(["gen", lang.name, key, "plugin"])

    if not hasattr(ctx.executable, plugin_binary_key):
        fail("Plugin executable not configured: %s" % plugin_binary_key)

    file = getattr(ctx.executable, plugin_binary_key)
    tool = get_offset_path(self["execdir"], file.path)

    self["inputs"] += [file]
    self["args"] += ["--plugin=%s=%s" % (plugin.name, tool)]


def build_grpc_invocation(lang, self):
    """Build a --plugin option if required for grpc service generation"""
    build_plugin_invocation("grpc", lang, self)


def build_protobuf_invocation(lang, self):
    """Build a --plugin option if required for basic protobuf generation"""
    build_plugin_invocation("protobuf", lang, self)


def build_inputs(lang, self):
    """Build a list of inputs to the ctx.action protoc"""
    self["inputs"] += self["protos"]


def post_execute(lang, self):
    """No default post-execute actions"""
    pass


def get_primary_output_suffix(lang, self):
    """The name of the implicit target that names the generated pb source files."""
    return ".pb"


CLASS = struct(
    name = "base",

    protobuf = struct(
        requires = [
            "protobuf",
            "external_protoc",
            "third_party_protoc",
        ]
    ),

    build_generated_files = build_generated_files,
    build_generated_filename_extensions = build_generated_filename_extensions,
    build_grpc_invocation = build_grpc_invocation,
    build_grpc_out = build_grpc_out,
    build_imports = build_imports,
    build_inputs = build_inputs,
    build_package_prefix = build_package_prefix,
    build_protobuf_invocation = build_protobuf_invocation,
    build_protobuf_out = build_protobuf_out,
    get_primary_output_suffix = get_primary_output_suffix,

    implement_compile_attributes = implement_compile_attributes,
    implement_compile_outputs = implement_compile_outputs,
    implement_compile_output_to_genfiles = implement_compile_output_to_genfiles,
    post_execute = post_execute,
)
